// Code generated by protoc-gen-firestore. DO NOT EDIT.
// versions:
// source: example.proto

package example

import (
	"cloud.google.com/go/firestore"
	"context"
	"fmt"
	"github.com/golang/protobuf/ptypes"
	"google.golang.org/api/iterator"
	"google.golang.org/genproto/protobuf/field_mask"
)

func GetExample(ctx context.Context, client *firestore.Client, collection, name string) (*Example, error) {

	if client == nil {
		return nil, fmt.Errorf("firestore client is nil")
	}

	d, err := client.Collection(collection).Doc(name).Get(ctx)
	if err != nil {
		return nil, err
	}

	var doc Example
	if err := d.DataTo(&doc); err != nil {
		return nil, fmt.Errorf("error converting Firestore document to %T: %v", doc, err)
	}

	doc.Name = name
	return &doc, nil
}

func CreateExample(ctx context.Context, client *firestore.Client, collection string, doc *Example) error {

	if client == nil {
		return fmt.Errorf("CreateExample: firestore client is nil")
	}

	doc.UpdatedBy = maui.GetUsernameFromMetadata(ctx)
	doc.Created = ptypes.TimestampNow()

	_, err := client.Collection(collection).Doc(doc.Name).Set(ctx, doc)
	if err != nil {
		return fmt.Errorf("CreateExample: %w", err)
	}

	return nil
}

func DeleteExample(ctx context.Context, client *firestore.Client, collection, name string) error {
	if client == nil {
		return fmt.Errorf("firestore client is nil")
	}

	_, err := client.Collection(collection).Doc(name).Delete(ctx)
	if err != nil {
		return fmt.Errorf("DeleteExample: %w", err)
	}
	return nil
}

func UpdateExample(ctx context.Context, client *firestore.Client, collection string, req *ExampleUpdateRequest) error {
	if client == nil {
		return fmt.Errorf("firestore client is nil")
	}

	// Add the system-mandated fields to the field mask
	mask := field_mask.FieldMask{
		Paths: []string{"updated_by", "updated"},
	}

	if req.UpdateMask == nil {
		return fmt.Errorf("UpdateExample: field mask is nil")
	}

	// TODO: prevent unauthorized update of the UpdatedBy and Updated field
	// Only allow some accounts the ability to override the system-generated fields,
	/// such as for batch loading / transfers, etc. For now, block any outside updates.

	for _, p := range req.UpdateMask.paths {
		for _, x := range []string{"updated_by", "updated", "name"} {
			if p == x {
				return fmt.Errorf("UpdateExample updating '%s': Updates to '%s' not permitted", req.Name, x)
			}
		}
	}

	// TODO: Proto field masks can be "a.b", Firestore expects ["a","b"]. This difference doesn't matter for rules.
	mask.Paths = append(mask.Paths, req.UpdateMask.Paths...)

	fps := []firestore.FieldPath{}
	for _, p := range mask.Paths {
		fps = append(fps, []string{p})
	}

	req.Rule.UpdatedBy = maui.GetUsernameFromMetadata(ctx)
	req.Rule.Updated = ptypes.TimestampNow()

	_, err := client.Collection(collection).Doc(req.Example.Name).Set(ctx, req.Example, firestore.Merge(fps...))

	if err != nil {
		return fmt.Errorf("UpdateExample: error saving '%s': %v", req.Example.Name, err)
	}
	return nil
}

func ListExamples(ctx context.Context, client *firestore.Client, collection string, req *ExampleUpdateRequest) (*ExampleList, error) {

	if client == nil {
		return fmt.Errorf("firestore client is nil")
	}

	limit := 50

	if limit > 50 || limit < 0 {
		limit = 50
	}

	pl := ExampleList{}

	pl.Examples = make([]*Example, 0, limit)

	query := client.Collection(collection)

	iter := query.Documents(ctx)

	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}
		var p Example
		if err := doc.DataTo(&p); err != nil {
			return nil, fmt.Errorf("converting Firestore document %T: %v", p, err)
		}
		p.Name = doc.Ref.ID
		pl.Examples = append(pl.Examples, &p)
	}
	return &pl, nil
}
